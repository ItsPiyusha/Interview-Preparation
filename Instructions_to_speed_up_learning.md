Q- solve only quality questions, where to get to learn new things, basically, level-up questions  
P- Understand the pattern among the following:  
| #  | Pattern Name                    | Use Case / What it Solves                                                                             | When to Use It (✅ So When Do They Work?)                                                                     |
| -- | ------------------------------- | ----------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| 1  | **Sliding Window**              | Fixed/variable-sized subarrays or substrings where you compute max/min/count/sum efficiently          | ✅ When the problem asks for **subarray/window of size K**, or **longest/shortest subarray** with a condition |
| 2  | **Two Pointers**                | Sorted arrays/strings where two elements need to be compared, or you need to compress/expand a window | ✅ Use when comparing two ends, like pairs with sum, or removing duplicates in-place                          |
| 3  | **Fast & Slow Pointers**        | Linked list cycle detection, finding middle node or palindrome                                        | ✅ Use in linked lists when you need to detect loops or get middle efficiently                                |
| 4  | **Merge Intervals**             | Merging overlapping intervals or finding free time slots                                              | ✅ When you have intervals and need to find **combined ranges**, overlaps, or gaps                            |
| 5  | **Cyclic Sort**                 | Finding missing numbers, duplicates in range 1 to N                                                   | ✅ Use when array contains numbers from 1 to N or 0 to N and you want O(1) space                              |
| 6  | **In-place Reversal / Reverse** | Reversing part of arrays/strings/linked lists                                                         | ✅ Used in string reversal, linked list segment reversal, etc.                                                |
| 7  | **Breadth-First Search (BFS)**  | Level-wise traversal in trees/graphs, shortest path in unweighted graphs                              | ✅ Use when problem says **minimum steps**, **levels**, or **shortest path in unweighted graph**              |
| 8  | **Depth-First Search (DFS)**    | Exploring all paths (backtracking), counting components, island problems                              | ✅ Use in matrix problems like island counting, flood fill, or for recursion-heavy tree/graph problems        |
| 9  | **Backtracking**                | Generating combinations, permutations, or all solutions to constraint-based problems                  | ✅ When you need **all possible ways**, e.g., N-Queens, Sudoku, Palindrome partitioning                       |
| 10 | **Dynamic Programming (DP)**    | Optimal substructure problems — maximizing, minimizing, or counting outcomes                          | ✅ When solution involves **choices + overlapping subproblems**, e.g., knapsack, LIS, LCS, DP on grid         |
| 11 | **Greedy**                      | Always making the locally best choice to find globally optimal answer                                 | ✅ Use when **local optimal choice leads to global**, e.g., activity selection, coin change (unlimited coins) |
| 12 | **Binary Search**               | Search in sorted array, or monotonic function                                                         | ✅ When function/input is **sorted or monotonic** (like “isPossible” in range)                                |
| 13 | **Bit Manipulation**            | Problems involving parity, set bits, XOR, power of 2                                                  | ✅ When constraints are tight and use of **bits** gives O(1) optimization or XOR trick                        |
| 14 | **Topological Sort / Graph**    | Ordering dependencies (e.g., Course Schedule), cycle detection                                        | ✅ When you need to **order tasks with dependencies** or **detect cycles** in directed graphs                 |

C- participate in contests  
D- Diversify topics, which means cover all the topics, don't get stuck in a single topic for long  
